 CorrecciÃ³n de subdominios forzados y navegaciÃ³n inteligente segÃºn el rol
yaml
Copiar
Editar
Vamos a corregir la redirecciÃ³n errÃ³nea que fuerza siempre el subdominio "doctor" al iniciar la app MediConnect. El objetivo de este bloque es asegurar que:

1. El usuario sea redirigido al subdominio correcto segÃºn su rol (paciente, mÃ©dico, admin, laboratorio).
2. No se fuerce ningÃºn subdominio por defecto al cargar la pÃ¡gina.
3. Se elimine cualquier lÃ³gica de fallback que siempre dirija al portal de mÃ©dicos.
4. La navegaciÃ³n y autenticaciÃ³n funcionen correctamente desde la pÃ¡gina principal (`www.dominio.com`) y desde cada subdominio (ej. `doctor.dominio.com`).

---

ğŸ”’ SEGURIDAD Y AUTENTICACIÃ“N

ğŸ”¹ AsegÃºrate de que al hacer login, se guarde correctamente en `localStorage` el rol del usuario (`role: doctor | patient | admin | lab`).

ğŸ”¹ Usa `AuthContext` o el contexto de sesiÃ³n para acceder al rol en cualquier punto de la aplicaciÃ³n.

ğŸ”¹ Crea una funciÃ³n central llamada `redirectToRoleSubdomain(role)` que haga lo siguiente:

```js
function redirectToRoleSubdomain(role) {
  const subdomains = {
    doctor: 'doctor.dominio.com',
    patient: 'patient.dominio.com',
    admin: 'admin.dominio.com',
    lab: 'lab.dominio.com'
  };
  const url = subdomains[role] || 'www.dominio.com';
  window.location.replace(`https://${url}`);
}
ğŸ› ï¸ Si estÃ¡s en modo local con Replit, usa rutas tipo ?subdomain=doctor para simular el entorno y adapta redirectToRoleSubdomain a reconocer y validar esa variable.

ğŸŒ SUBDOMINIOS INTELIGENTES Y CONTEXTO

ğŸ”¹ AsegÃºrate de que App.jsx (o App.tsx) tenga un hook como este para detectar en quÃ© subdominio estÃ¡s y evitar conflicto:

js
Copiar
Editar
function getCurrentSubdomain() {
  const host = window.location.hostname;
  const parts = host.split('.');
  if (host.includes('replit.dev')) {
    const query = new URLSearchParams(window.location.search);
    return query.get('subdomain') || 'public';
  }
  return parts.length > 2 ? parts[0] : 'public';
}
ğŸ”¹ Usa esta funciÃ³n para determinar quÃ© DashboardLayout o LoginRoute cargar. Si el subdominio es incorrecto para el rol actual, redirÃ­gelo con redirectToRoleSubdomain().

ğŸ“¦ RUTAS ESTRUCTURADAS

ğŸ”¹ En tu archivo de rutas (AppRoutes.jsx o similar), crea rutas protegidas por rol:

jsx
Copiar
Editar
<Route path="/dashboard" element={<RoleProtectedRoute role="doctor"><DoctorDashboard /></RoleProtectedRoute>} />
<Route path="/dashboard" element={<RoleProtectedRoute role="patient"><PatientDashboard /></RoleProtectedRoute>} />
<Route path="/dashboard" element={<RoleProtectedRoute role="admin"><AdminDashboard /></RoleProtectedRoute>} />
ğŸ”¹ En el componente <RoleProtectedRoute />, valida que el subdominio actual sea el correcto. Si no lo es, redirige automÃ¡ticamente con:

js
Copiar
Editar
useEffect(() => {
  if (getCurrentSubdomain() !== role) {
    redirectToRoleSubdomain(role);
  }
}, []);
ğŸ“ DETECCIÃ“N CORRECTA EN index.html O ROOT

ğŸ”¹ En index.html o index.js, verifica si el usuario ya estÃ¡ autenticado y tiene rol guardado. Si lo tiene, llama a redirectToRoleSubdomain(role) directamente para mandarlo al lugar correcto sin errores ni fallback al subdominio "doctor".

ğŸš¨ ELIMINAR COMPORTAMIENTO DEFECTUOSO

ğŸ”¹ Revisa si en algÃºn archivo tienes lÃ­neas como:

js
Copiar
Editar
window.location.replace("?subdomain=doctor");
o similares. Deben ser eliminadas o reemplazadas por redirectToRoleSubdomain() correctamente parametrizada.

ğŸ§ª TESTING

ğŸ”¸ Usa sesiones de prueba con diferentes correos (admin@, doctor@, paciente@) para validar que:

Desde la pÃ¡gina principal, al hacer login, el usuario sea redirigido correctamente segÃºn su rol.

Al escribir mal un subdominio, el sistema no caiga en emergencia sino que muestre error o redireccione.

Las sesiones se mantengan estables al navegar entre pÃ¡ginas del mismo subdominio.

